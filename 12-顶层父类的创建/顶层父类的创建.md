

# 当代软件架构实践中的经验

> - 这门课的目标是创建一个可复用(在不同的工程中可以使用课中的数据结构库)的数据结构类库：DTLib.
> - 尽量使用**单重继承**的方式进行系统设计，可以实现多个接口的设计，继承的话只能是一对一的继承，千万不能让一个类继承多个父类
> - 尽量保持系统中只存在**单一的继承树** 
> - 尽量使用**组合关系**代替继承关系，创建一个顶层抽象父类来保证的
> - 吐槽C++：具有各种编程模式：支持面向过程/对象的编程、泛型编程，实践中多重继承只能让系统一堆Bug。
> - new操作失败会发生什么：失败的时候回抛出标准库的异常，这就给创建一个可复用的库带来了一定的困难
>
> ```c++
> noexcept 关键字：从C++11开始，我们能看到很多代码当中都有关键字noexcept。
> ```

> 该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。
>  如果在运行时，noexecpt 函数向外抛出了异常（如果函数内部捕捉了异常并完成处理，这种情况不算抛出异常），程序会直接终止，调用std::terminate()函数，该函数内部会调用std::abort()终止程序。 

# 创建 DTLib::Object 类的意义

> - 遵循经典设计准则，所有数据都继承自 Object (单一继承树)
>
> - 定义动态内存申请的行为，提高代码的移植性(统一编译器行为)
>
> - # 顶层父类的接口定义
>
>   ​        
>
>   ```c++
>   class Object
>   {
>   public:
>       void *operator new (unsigned int size) noexcept;
>       void operator delete (void *p);
>       void *operator new[] (unsigned int size) noexcept;
>       void operator delete[] (void *p);
>       virtual ~Object() = 0;//子类都会有虚函数表的指针，动态类型识别
>   };
>   ```

 此处的new和delete是自定义的new和delete的操作符重载函数，定义它们的原因是：在不同的编译器下用new和delete的时候行为都是相同的。

new和malloc https://www.cnblogs.com/shilinnpu/p/8945637.html